package enroll

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"flag"
	"fmt"
	iofs "io/fs"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/google/uuid"

	"github.com/pingsantohq/agent/internal/certs"
	"github.com/pingsantohq/agent/internal/config"
)

const defaultDataDir = "/var/lib/pingsanto/agent"

type Dependencies struct {
	Issuer certs.Issuer
	Now    func() time.Time
	Verify func(context.Context, string, *certs.Response) error
}

func (d *Dependencies) ensure() {
	if d.Issuer == nil {
		d.Issuer = certs.NewHTTPIssuer(nil)
	}
	if d.Now == nil {
		d.Now = time.Now
	}
	if d.Verify == nil {
		d.Verify = func(ctx context.Context, server string, resp *certs.Response) error {
			if resp == nil {
				return nil
			}
			if len(resp.CertPEM) == 0 || len(resp.KeyPEM) == 0 {
				return nil
			}
			return certs.VerifyConnection(ctx, server, resp.CertPEM, resp.KeyPEM, resp.CAPEM)
		}
	}
}

func Run(ctx context.Context, args []string, deps Dependencies) error {
	deps.ensure()

	fs := flag.NewFlagSet("enroll", flag.ContinueOnError)
	server := fs.String("server", "", "PingSanto central server URL (required)")
	token := fs.String("token", "", "Enrollment token generated by central (required)")
	labels := fs.String("labels", "", "Comma-separated label assignments (e.g. site=ATL-1,isp=Comcast)")
	dataDir := fs.String("data-dir", defaultDataDir, "Agent data directory")
	configPath := fs.String("config-path", config.DefaultConfigPath, "Destination for signed agent config")

	if err := fs.Parse(args); err != nil {
		return err
	}

	if *server == "" {
		return fmt.Errorf("--server is required")
	}
	if *token == "" {
		return fmt.Errorf("--token is required")
	}

	if err := os.MkdirAll(*dataDir, 0o700); err != nil {
		return fmt.Errorf("ensure data dir %q: %w", *dataDir, err)
	}

	statePath := config.StatePath(*dataDir)
	if _, err := os.Stat(statePath); err == nil {
		return fmt.Errorf("agent already enrolled: state file %q exists", statePath)
	} else if err != nil && !errors.Is(err, iofs.ErrNotExist) {
		return fmt.Errorf("check state file %q: %w", statePath, err)
	}

	labelMap, err := parseLabels(*labels)
	if err != nil {
		return err
	}

	req := certs.Request{
		Server:  *server,
		Token:   *token,
		Labels:  labelMap,
		DataDir: *dataDir,
	}

	resp, err := deps.Issuer.Enroll(ctx, req)
	if err != nil {
		return fmt.Errorf("enrollment request failed: %w", err)
	}
	if err := deps.Verify(ctx, *server, resp); err != nil {
		return fmt.Errorf("mTLS verification failed: %w", err)
	}

	agentID := ""
	if resp != nil && resp.AgentID != "" {
		agentID = resp.AgentID
	}
	if agentID == "" {
		agentID = "agt_" + strings.ReplaceAll(uuid.NewString(), "-", "")
	}

	state := config.State{
		AgentID:    agentID,
		Server:     *server,
		Labels:     labelMap,
		EnrolledAt: deps.Now().UTC(),
		CertPath:   filepath.Join(*dataDir, "client.crt"),
		KeyPath:    filepath.Join(*dataDir, "client.key"),
		CAPath:     filepath.Join(*dataDir, "ca.pem"),
		ConfigPath: *configPath,
	}
	sum := sha256.Sum256([]byte(*token))
	state.Credentials.TokenHash = hex.EncodeToString(sum[:])

	if resp != nil {
		paths := certs.Paths{
			Cert: state.CertPath,
			Key:  state.KeyPath,
			CA:   state.CAPath,
		}
		if err := certs.Persist(paths, resp); err != nil {
			return err
		}
		if err := config.WriteSignedConfig(*configPath, resp.ConfigYAML); err != nil {
			return err
		}
	}

	if err := config.SaveState(ctx, *dataDir, state); err != nil {
		return err
	}

	fmt.Printf("Enrollment complete. Agent ID: %s\n", agentID)
	return nil
}

func parseLabels(input string) (map[string]string, error) {
	result := make(map[string]string)
	if strings.TrimSpace(input) == "" {
		return result, nil
	}

	pairs := strings.Split(input, ",")
	for _, pair := range pairs {
		pair = strings.TrimSpace(pair)
		if pair == "" {
			continue
		}
		parts := strings.SplitN(pair, "=", 2)
		if len(parts) != 2 {
			return nil, fmt.Errorf("invalid label %q (expected key=value)", pair)
		}
		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])
		if key == "" || value == "" {
			return nil, fmt.Errorf("invalid label %q (key and value required)", pair)
		}
		result[key] = value
	}

	return result, nil
}
